class Solution {
	int alin = 0;
	int dfs(int node, int par, int[] parent, int[] infnode, int[][] map, Set<Integer> set, int[] visit) {
		parent[node] = par;
		visit[node] = 1;
		if (set.contains(node)) {
			infnode[par]++;
		}
		int ans = 1;
		for (int next = 0; next < map.length; next++) {
			if (visit[next] == 0 && map[node][next] == 1) {
				ans += dfs(next,par,parent,infnode,map,set,visit);
			}
		}
		return ans;
	}
	int minMalwareSpread(int[][] graph, int[] initial) {
		int ans = Integer.MAX_VALUE;
		int n = graph.length;
		int maxin = 0;
		int[] parent = new int[n];
		int[] infnode = new int[n];
		Set<Integer> set = new HashSet<>();
		for (int i: initial) {	
			set.add(i);
		}
		int[] size = new int[n];
		for (int i: initial) {	
			if (parent[i] != 0) {
				infnode[i] = infnode[parent[i]];
				parent[i] = parent[i];
				size[i] = size[parent[i]];
				continue;
			}
			int[] visit = new int[n];
			size[i] = dfs(i,i,parent,infnode,graph,set,visit);
		}
		for (int i: initial) {	
			if (infnode[i] == 1) {
				if (ans == Integer.MAX_VALUE) {
					maxin = size[i];
					ans = i;
				} 
				else if (maxin < size[i]) {
					ans = i;
					maxin = size[i];
				} 
				else if (maxin == size[i] && i < ans) {
					ans = i;
				}
			}
		}
		if (ans == Integer.MAX_VALUE) {
			for (int node: initial) {	
				ans = Math.min(ans,node);
			}
		}
		return ans;
	}
}