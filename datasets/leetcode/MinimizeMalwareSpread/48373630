class Solution {
	int[] parent, size;
	int findUPar(int u) {
		if (u == parent[u]) {
			return u;
		}
		return parent[u] = findUPar(parent[u]);
	}
	int minMalwareSpread(int[][] graph, int[] initial) {
		int n = graph.length;
		parent = new int[n];
		size = new int[n];
		for (int i = 0; i < n; i++) {
			parent[i] = i;
			size[i] = 1;
		}
		for (int i = 0; i < n; i++) {
			for (int j = i + 1; j < n; j++) {
				if (graph[i][j] == 1) {
					unionBySize(i,j);
				}
			}
		}
		int[] count = new int[n];
		for (int i: initial) {	
			int ulp = findUPar(i);
			count[ulp]++;
		}
		int ans = Integer.MAX_VALUE;
		int maxSize = 0;
		int minNode = Integer.MAX_VALUE;
		for (int i: initial) {	
			int ulp = findUPar(i);
			if (count[ulp] == 1) {
				if (maxSize < size[ulp]) {
					maxSize = size[ulp];
					ans = i;
				} 
				else if (maxSize == size[ulp]) {
					ans = Math.min(ans,i);
				}
			}
			minNode = Math.min(minNode,i);
		}
		return (ans == Integer.MAX_VALUE) ? minNode : ans;
	}
	void unionBySize(int u, int v) {
		int ulp_u = findUPar(u);
		int ulp_v = findUPar(v);
		if (ulp_u == ulp_v) {
			return;
		}
		if (size[ulp_u] >= size[ulp_v]) {
			size[ulp_u] += size[ulp_v];
			parent[ulp_v] = ulp_u;
		} 
		else {
			size[ulp_v] += size[ulp_u];
			parent[ulp_u] = ulp_v;
		}
	}
}